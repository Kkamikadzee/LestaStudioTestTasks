#### Тестовое задание на вакансию Junior programmer (Python, C++)

## Задание 1.
Текст заданаия:
> 1.На языке Python или С/С++, написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути.
Объяснить плюсы и минусы обеих реализаций.
Python example:
def isEven(value):return value%2==0
C/C++ example:
bool isEven(int value){return value%2==0;}

В задание представлен пример функции в виде:

```cpp
bool isEven(int value)
{
	return value % 2 == 0;
}
```

Для начала смею предложить изменить функцию и сделать её встраиваемой, благодаря чему можно будет избавиться от временных затрат на вызов функции. У встраиваемых функций есть один критический минус - они раздувают объектный файл, но, так как наша функция состоит всего из одной строки, данная проблема возникнуть не должна.

```cpp
inline bool isEven1(int value)
{
	return value % 2 == 0;
}
```

Для реализации второго варианта функции определения чётности числа, используем побитовый оператор И, вместо остатка от деления.


```cpp
inline bool isEven3(int value)
{
	return value & 1 == 0;
}
```

Данная реализация должна быть быстрее, но это можно обнаружить, если не использовать оптимизации у компилятора. Могу предположить, что на этапе оптимизации операции остатка деления на два, заменяются на логическое умножение на единицу.
**Реализация: [тык](https://github.com/Kkamikadzee/LestaStudioTestTasks/blob/dev/Task1/main.cpp "тык").**

## Задание 2.
Текст заданаия:
> На языках Python(2.7) и/или С++, написать минимум по 2 класса реализовывающих циклический буфер. 
Объяснить плюсы и минусы каждой реализации.

Мною было реализована два варианта циклического буфера.
1. Буфер фиксированного размера, где данные хранятся в массиве.
**Реализации: [C++](https://github.com/Kkamikadzee/LestaStudioTestTasks/blob/dev/Task2/CircularBufferCpp/include/CircularBufferArray.h "C++"), [Python](https://github.com/Kkamikadzee/LestaStudioTestTasks/blob/dev/Task2/CircularBufferPython/CircularBufferArray.py "Python")**
2. Буфер динамического размера, где данные хранятся в узлах, аналогично листу.
**Реализации: [C++](https://github.com/Kkamikadzee/LestaStudioTestTasks/blob/dev/Task2/CircularBufferCpp/include/CircularBufferList.h "C++"), [Python](https://github.com/Kkamikadzee/LestaStudioTestTasks/blob/dev/Task2/CircularBufferPython/CircularBufferList.py "Python")**

Первый вариант требует меньше памяти, чем второй, но при этом имеет, как ни странно, фиксированный размер.
Вторая реализация занимает больше памяти на один элемент в коллекции, из-за наличия указателей на предыдущий и следующий элементы. Но она имеет динамический размер. Также этому варианту не требуется непрерывный участок памяти для массива, который будет хранить данные, но выделение памяти под каждый узел может негативно повлиять на фрагментированность виртуальной памяти.

Буфер динамического размера можно было реализовать и через динамический массив. Но тогда сложость удаления и вставки элементов будет O(n), а реализация через "лист" имеет сложность O(1).

## Задание 3.
Текст задания:
> На языке Python или С/С++, написать функцию, которая быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел.
Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным).
Объяснить почему вы считаете, что функция соответствует заданным критериям.

Исходя из информации, что это числа, можно предположить, что устойчивость алгоритма нас не сильно заботит. 

Далее следует информация о том, что порядок размер коллекции и порядок значений в ней случаен, следовательно нас в большей степени должна интересовать сложность алгоритма "в худшем случае".

Исходя из вышеописанных доводов (особенно из информации, что сортируется коллекция именно с числами), мной был выбрана поразрядная сортировка c выравниванием по младшему разряду и сортировка подсчётом.

Вкратце алгоритм таков: на каждом i-ом шаге алгоритма сортируем коллекцию по первым 'N * i' бита. То есть таких операций будет 'sizeof(value_type) / N'. На каждом таком шаге будем использовать сортировку подсчётом, которая потребует '2 ^ N' памяти.

Проблема выбранного алгоритма заключается в том, что нам необходимо знать дополнительную информацию о данных: являются ли они вещественными, просто целыми или беззнаковыми.

Реализованный мною вариант сортирует беззнаковые числа. Добавление возможности сортировать вещественные и просто целые числа, не является затруднительным, но при этом потребует дополнительных вычислений перед сортировкой и после. Исходя из начальных данных, считаю данное решение оптимальным.

**Реализация: [тык](https://github.com/Kkamikadzee/LestaStudioTestTasks/blob/dev/Task3/include/RadixSort.h "тык").**
